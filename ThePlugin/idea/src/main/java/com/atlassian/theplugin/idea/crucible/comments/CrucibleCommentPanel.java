package com.atlassian.theplugin.idea.crucible.comments;

import com.intellij.openapi.actionSystem.DataContext;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.ui.DialogWrapper;
import com.intellij.uiDesigner.core.Spacer;
import com.intellij.CommonBundle;
import com.jgoodies.forms.layout.FormLayout;
import com.jgoodies.forms.layout.CellConstraints;
import com.atlassian.theplugin.idea.crucible.ReviewDataInfoAdapter;
import com.atlassian.theplugin.idea.IdeaHelper;
import com.atlassian.theplugin.commons.crucible.CrucibleServerFacade;
import com.atlassian.theplugin.commons.crucible.CrucibleServerFacadeImpl;
import com.atlassian.theplugin.commons.crucible.api.model.*;
import com.atlassian.theplugin.commons.remoteapi.RemoteApiException;
import com.atlassian.theplugin.commons.exception.ServerPasswordNotProvidedException;
import com.atlassian.theplugin.commons.Server;
import com.atlassian.theplugin.util.PluginUtil;

import javax.swing.*;
import javax.swing.event.ListSelectionListener;
import javax.swing.event.ListSelectionEvent;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.util.List;

import org.jetbrains.annotations.Nullable;

/**
 * Created by IntelliJ IDEA.
 * User: pmaruszak
 * Date: Jul 7, 2008
 * Time: 2:22:53 PM
 * To change this template use File | Settings | File Templates.
 */
public class CrucibleCommentPanel extends JPanel implements ListSelectionListener, ListCellRenderer {
	public static Map<Integer, List<CustomFieldDef>> METRICS_VERSIONS = new HashMap<Integer, List<CustomFieldDef>>();
	protected DefaultListCellRenderer defaultRenderer = new DefaultListCellRenderer();

	private JPanel rootPanel;
	private JTextArea commentTextArea;
	private JCheckBox defectCheckBox;
	private JButton postButton;
	private JButton saveAsDraftButton;
	private JButton cancelButton;
	private JButton editTopButton;
	private JButton replyTopButton;
	private JButton deleteTopButton;
	private JButton postTopButton;
	private JComboBox rankComboBox;
	private JComboBox classificationComboBox;
	private JList replyList;
	private JPanel replyPanel;
	private JPanel topButtonsPanel;
	private JPanel bottomButtonsPanel;
	private JLabel commentTypeTopLabel;
	private JLabel generalInfoTopLabel;
	private JTextPane commentPanel;
	private final ReviewDataInfoAdapter reviewAdapter;
	private final Project project;
	private final CrucibleServerFacade crucibleFacade = CrucibleServerFacadeImpl.getInstance();
	private GeneralComment comment;
	private final CommentType commentType;
	private final CommentState commentState = CommentState.READ_ONLY;
	private static final String RANK = "rank";
	private static final String CLASSIFICATION = "classification";
	private final DefaultListModel listModel;
	private final DataContext dataContext;

	public JPanel getRootPanel() {
		return rootPanel;
	}

	public void valueChanged(ListSelectionEvent event) {
		//To change body of implemented methods use File | Settings | File Templates.
	}

	public Component getListCellRendererComponent(JList jList, Object o, int i, boolean b, boolean b1) {

		return new CrucibleCommentPanel(this.dataContext, this.reviewAdapter, ((GeneralComment) o));
	}

	/**
	 * Method generated by IntelliJ IDEA GUI Designer
	 * >>> IMPORTANT!! <<<
	 * DO NOT edit this method OR call it in your code!
	 *
	 * @noinspection ALL
	 */
	private void $$$setupUI$$$() {
		rootPanel = new JPanel();
		rootPanel.setLayout(new FormLayout("fill:d:grow", "center:28px:noGrow,center:d:grow,center:m:noGrow,center:max(d;4px):noGrow"));
		final JScrollPane scrollPane1 = new JScrollPane();
		CellConstraints cc = new CellConstraints();
		rootPanel.add(scrollPane1, cc.xy(1, 2, CellConstraints.FILL, CellConstraints.FILL));
		scrollPane1.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), null));
		commentTextArea = new JTextArea();
		commentTextArea.setText("");
		scrollPane1.setViewportView(commentTextArea);
		bottomButtonsPanel = new JPanel();
		bottomButtonsPanel.setLayout(new FormLayout("fill:67px:noGrow,left:4dlu:noGrow,fill:m:noGrow,fill:m:noGrow,fill:d:grow,fill:m:noGrow,fill:m:noGrow,fill:max(m;4px):noGrow", "center:d:noGrow"));
		rootPanel.add(bottomButtonsPanel, cc.xy(1, 3, CellConstraints.FILL, CellConstraints.CENTER));
		postButton = new JButton();
		postButton.setText("Post");
		bottomButtonsPanel.add(postButton, cc.xy(7, 1, CellConstraints.RIGHT, CellConstraints.DEFAULT));
		saveAsDraftButton = new JButton();
		saveAsDraftButton.setText("Save As Draft");
		bottomButtonsPanel.add(saveAsDraftButton, cc.xy(6, 1, CellConstraints.RIGHT, CellConstraints.DEFAULT));
		defectCheckBox = new JCheckBox();
		defectCheckBox.setText("Defect");
		bottomButtonsPanel.add(defectCheckBox, cc.xy(1, 1, CellConstraints.LEFT, CellConstraints.DEFAULT));
		cancelButton = new JButton();
		cancelButton.setText("Cancel");
		bottomButtonsPanel.add(cancelButton, cc.xy(8, 1, CellConstraints.RIGHT, CellConstraints.DEFAULT));
		rankComboBox = new JComboBox();
		bottomButtonsPanel.add(rankComboBox, cc.xy(3, 1, CellConstraints.LEFT, CellConstraints.DEFAULT));
		classificationComboBox = new JComboBox();
		bottomButtonsPanel.add(classificationComboBox, cc.xy(4, 1, CellConstraints.LEFT, CellConstraints.DEFAULT));
		final Spacer spacer1 = new Spacer();
		bottomButtonsPanel.add(spacer1, cc.xy(5, 1, CellConstraints.FILL, CellConstraints.DEFAULT));
		topButtonsPanel = new JPanel();
		topButtonsPanel.setLayout(new FormLayout("fill:m:grow,left:34dlu:noGrow,fill:d:grow,fill:m:noGrow,fill:max(m;4px):noGrow,fill:max(m;4px):noGrow,fill:max(m;4px):noGrow", "center:m:noGrow"));
		rootPanel.add(topButtonsPanel, cc.xy(1, 1));
		editTopButton = new JButton();
		editTopButton.setText("Edit");
		topButtonsPanel.add(editTopButton, cc.xy(5, 1, CellConstraints.RIGHT, CellConstraints.DEFAULT));
		replyTopButton = new JButton();
		replyTopButton.setText("Reply");
		topButtonsPanel.add(replyTopButton, cc.xy(4, 1, CellConstraints.RIGHT, CellConstraints.CENTER));
		deleteTopButton = new JButton();
		deleteTopButton.setText("Delete");
		topButtonsPanel.add(deleteTopButton, cc.xy(6, 1, CellConstraints.RIGHT, CellConstraints.DEFAULT));
		postTopButton = new JButton();
		postTopButton.setText("Post");
		topButtonsPanel.add(postTopButton, cc.xy(7, 1, CellConstraints.RIGHT, CellConstraints.DEFAULT));
		commentTypeTopLabel = new JLabel();
		commentTypeTopLabel.setText("Label");
		topButtonsPanel.add(commentTypeTopLabel, cc.xy(2, 1, CellConstraints.FILL, CellConstraints.DEFAULT));
		generalInfoTopLabel = new JLabel();
		generalInfoTopLabel.setText("Label");
		topButtonsPanel.add(generalInfoTopLabel, cc.xy(1, 1, CellConstraints.FILL, CellConstraints.DEFAULT));
		final Spacer spacer2 = new Spacer();
		topButtonsPanel.add(spacer2, cc.xy(3, 1, CellConstraints.FILL, CellConstraints.DEFAULT));
		replyPanel = new JPanel();
		replyPanel.setLayout(new FormLayout("fill:d:grow", "center:80px:grow"));
		rootPanel.add(replyPanel, cc.xy(1, 4, CellConstraints.DEFAULT, CellConstraints.FILL));
		final JScrollPane scrollPane2 = new JScrollPane();
		replyPanel.add(scrollPane2, new CellConstraints(1, 1, 1, 1, CellConstraints.FILL, CellConstraints.FILL, new Insets(0, 20, 0, 0)));
		replyList = new JList();
		scrollPane2.setViewportView(replyList);
	}

	/**
	 * @noinspection ALL
	 */
	public JComponent $$$getRootComponent$$$() {
		return rootPanel;
	}

	/* EDIT - comment in edit mode
			   READ_ONLY - comment that was not created by viewer in read only mode
			   READ_ONLY_EDITABLE - comment in read only mode created by viewer and can be edited
			* */
	public enum CommentState {
		NEW, EDIT, READ_ONLY
	}

	public enum CommentType {
		GENAREAL_COMMENT, FILE_COMMENT, LINE_COMMENT, REPLY
	}

	public static List<CustomFieldDef> getMetricsVersion(Server server, int metricVersion) {
		if (METRICS_VERSIONS.get(new Integer(metricVersion)) != null) {
			return METRICS_VERSIONS.get(new Integer(metricVersion));
		} else {
			try {
				List<CustomFieldDef> customFields = CrucibleServerFacadeImpl.getInstance().getMetrics(server, metricVersion);
				METRICS_VERSIONS.put(new Integer(metricVersion), customFields);
				return customFields;
			} catch (RemoteApiException e) {
				PluginUtil.getLogger().error(e.getMessage());
			} catch (ServerPasswordNotProvidedException e) {
				PluginUtil.getLogger().error(e.getMessage());
			}

			return null;
		}
	}


	public CrucibleCommentPanel(DataContext dataContext, ReviewDataInfoAdapter reviewAdapter, GeneralComment comment) {
		$$$setupUI$$$();
		commentType = determineCommentType(comment);
		this.project = IdeaHelper.getCurrentProject(dataContext);
		this.dataContext = dataContext;
		listModel = new DefaultListModel();
		replyList.setCellRenderer(this);
		replyList.setModel(listModel);
		replyList.addListSelectionListener(this);

		setComment(comment);
		this.reviewAdapter = reviewAdapter;

		rootPanel.registerKeyboardAction(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				onCancel();
			}
		}, KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);

		initActionListeners();
		setMode(CommentState.READ_ONLY);

		//replyList.setSelectionModel(ListSelectionModel.);


	}


	private void addReply(GeneralComment item) {
		listModel.addElement(item);
	}

	/*
	* Handles click on top reply button -> transits to some edit mode == no top buttons
	* Add new reply to comment
	* */
	private void newReply() {
		//
	}

	private void setComment(GeneralComment comment) {
		this.comment = comment;
		commentTextArea.setText(comment.getMessage());

		if (!comment.isReply() && comment.getReplies().size() > 0) {
			for (GeneralComment item : comment.getReplies()) {
				addReply(item);
			}
		} else {
			//do not show reply panel if no replies or REPLY
			replyPanel.setVisible(false);
		}
	}

	protected void initActionListeners() {
		postButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				onPost(false);
			}
		});

		saveAsDraftButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				onPost(true);
			}
		});

		cancelButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				setMode(CommentState.READ_ONLY);
			}
		});

		defectCheckBox.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				setDefectCombosVisible(defectCheckBox.isSelected());
			}
		});


		editTopButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				onTopEdit();
			}
		});

		replyTopButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				newReply();
			}
		});

		deleteTopButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				onTopDelete();
			}
		});

		postTopButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				onTopPost();
			}
		});
	}

	private void fillInDefectCombos() {
		List<CustomFieldDef> fieldsDef = getMetricsVersion(reviewAdapter.getServer(), reviewAdapter.getMetricsVersion());

		for (CustomFieldDef item : fieldsDef) {
			List<CustomFieldValue> values;
			if (item.getName().equals(RANK)) {
				values = item.getValues();
				rankComboBox.removeAllItems();
				rankComboBox.setName(item.getName());
				for (CustomFieldValue value : values) {
					rankComboBox.addItem(new CustomFieldValueComboBoxItem(value));

				}
			}
			if (item.getName().equals(CLASSIFICATION)) {
				values = item.getValues();
				classificationComboBox.removeAllItems();
				classificationComboBox.setName(item.getLabel());
				for (CustomFieldValue value : values) {
					classificationComboBox.addItem(new CustomFieldValueComboBoxItem(value));
				}

			}

		}


	}


	protected void onPost(boolean saveAsDraft) {
		GeneralCommentBean generalComment = new GeneralCommentBean();

		generalComment.setMessage(commentTextArea.getText());
		generalComment.setPermId(reviewAdapter.getPermaId());
		//generalComment.setUser(reviewAdapter.get);
		//???What about defect???
		generalComment.setDraft(saveAsDraft);

		try {
			crucibleFacade.addGeneralComment(reviewAdapter.getServer(), reviewAdapter.getPermaId(), generalComment);
		} catch (RemoteApiException e) {
			//@todo show message in window
			PluginUtil.getLogger().error(e.getMessage());
		} catch (ServerPasswordNotProvidedException e) {
			//@todo show message in window
			PluginUtil.getLogger().error(e.getMessage());
		}
	}

	private CommentType determineCommentType(GeneralComment comment) {
		if (comment.isReply()) {
			return CommentType.REPLY;
		}

		if (comment instanceof VersionedComment) {
			VersionedComment verComment = (VersionedComment) comment;

			if (verComment.isFromLineInfo() || verComment.isToLineInfo()) {
				return CommentType.LINE_COMMENT;
			} else {
				return CommentType.FILE_COMMENT;
			}
		}

		return CommentType.GENAREAL_COMMENT;
	}


	private void onTopDelete() {

	}

	private void onTopPost() {

	}

	/*
		* Disables all top buuttons and transits component to EDIT MODE = no top button only selected button on the bottom
		* */
	private void onTopEdit() {
		setMode(CommentState.EDIT);
	}

	private void onCancel() {

	}

	;

	private void setDefectCombosVisible(Boolean visible) {
		if (visible) {
			fillInDefectCombos();
			rankComboBox.setVisible(true);
			classificationComboBox.setVisible(true);
		} else {
			rankComboBox.setVisible(false);
			classificationComboBox.setVisible(false);
		}
	}

	private void setMode(CommentState commentState) {

		switch (commentState) {
			case EDIT:
				topButtonsPanel.setVisible(false);
				bottomButtonsPanel.setVisible(true);
				saveAsDraftButton.setVisible(false);
				//Reply do not have DEFECT check box
				if (comment.isReply()) {
					defectCheckBox.setVisible(false);
					setDefectCombosVisible(false);
				} else {
					defectCheckBox.setVisible(true);
					setDefectCombosVisible(defectCheckBox.isSelected());
				}
				break;
			case NEW:
				topButtonsPanel.setVisible(false);
				bottomButtonsPanel.setVisible(true);
				saveAsDraftButton.setVisible(true);
				defectCheckBox.setVisible(true);
				setDefectCombosVisible(defectCheckBox.isSelected());

				break;
			case READ_ONLY:
				//not editable, top panel visible, bottom panel not visible
				topButtonsPanel.setVisible(true);
				bottomButtonsPanel.setVisible(false);

				if (true || reviewAdapter.getCreator().equals(reviewAdapter.getServer().getUserName())) {
					//top EDIT, REPLY visible, editable
					editTopButton.setVisible(true);
					deleteTopButton.setVisible(true);
				} else {
					//top EDIT, REPLY not visible
					editTopButton.setVisible(false);
					deleteTopButton.setVisible(false);
				}

				//for drafts top POST button is visible
				if (comment.isDraft()) {
					postTopButton.setVisible(true);
				} else {
					postTopButton.setVisible(false);
				}
				//for REPLYies disable top REPLY button
				if (commentType == CommentType.REPLY) {
					replyTopButton.setVisible(false);
				} else {
					replyTopButton.setVisible(true);
				}


				break;


		}

	}

	private class CustomFieldValueComboBoxItem extends Object {
		private final CustomFieldValue value;

		public CustomFieldValueComboBoxItem(CustomFieldValue value) {
			this.value = value;
		}

		public String toString() {
			return value.getName();
		}

		public CustomFieldValue getUserData() {
			return value;
		}
	}
}

