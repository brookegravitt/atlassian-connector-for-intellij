package com.atlassian.theplugin.idea.crucible.comments;

import com.intellij.uiDesigner.core.Spacer;
import com.jgoodies.forms.layout.FormLayout;
import com.jgoodies.forms.layout.CellConstraints;
import com.atlassian.theplugin.commons.crucible.CrucibleServerFacade;
import com.atlassian.theplugin.commons.crucible.CrucibleServerFacadeImpl;
import com.atlassian.theplugin.commons.crucible.api.model.*;
import com.atlassian.theplugin.commons.remoteapi.RemoteApiException;
import com.atlassian.theplugin.commons.exception.ServerPasswordNotProvidedException;
import com.atlassian.theplugin.commons.Server;
import com.atlassian.theplugin.util.PluginUtil;
import com.atlassian.theplugin.idea.crucible.ReviewData;

import javax.swing.*;
import javax.swing.event.ListSelectionListener;
import javax.swing.event.ListSelectionEvent;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.util.List;

/**
 * Created by IntelliJ IDEA.
 * User: pmaruszak
 * Date: Jul 7, 2008
 * Time: 2:22:53 PM
 * To change this template use File | Settings | File Templates.
 */
public class CrucibleCommentPanel extends JPanel implements ListSelectionListener, ListCellRenderer {
	public static Map<Integer, List<CustomFieldDef>> METRICS_VERSIONS = new HashMap<Integer, List<CustomFieldDef>>();
	protected DefaultListCellRenderer defaultRenderer = new DefaultListCellRenderer();

	private JPanel rootPanel;
	private JTextArea commentTextArea;
	private JCheckBox defectCheckBox;
	private JButton postButton;
	private JButton saveAsDraftButton;
	private JButton cancelButton;
	private JButton editTopButton;
	private JButton replyTopButton;
	private JButton deleteTopButton;
	private JButton postTopButton;
	private JComboBox rankComboBox;
	private JComboBox classificationComboBox;
	private JList replyList;
	private JPanel replyPanel;
	private JPanel topButtonsPanel;
	private JPanel bottomButtonsPanel;
	private JLabel draftTopLabel;
	private JLabel authorTopLabel;
	private JLabel defectTopLabel;
	private ReviewData reviewData;
	private final CrucibleServerFacade crucibleFacade = CrucibleServerFacadeImpl.getInstance();
	private GeneralCommentBean comment;
	private CommentType commentType;
	private CommentState commentState = CommentState.NEW;
	private static final String RANK = "rank";
	private static final String CLASSIFICATION = "classification";
	private DefaultListModel listModel;
	private static String DRAFT = "DRAFT";
	private static String DEFECT = "DEFECT";


	public JPanel getRootPanel() {
		return rootPanel;
	}

	public void valueChanged(ListSelectionEvent event) {
		//To change body of implemented methods use File | Settings | File Templates.
	}

	public Component getListCellRendererComponent(JList jList, Object o, int i, boolean b, boolean b1) {
		CrucibleCommentPanel panel = new CrucibleCommentPanel(this.reviewData, ((GeneralComment) o));
		panel.setMinimumSize(panel.getPreferredSize());
		return panel.getRootPanel();
	}


	public Dimension getPreferredSize() {
		return rootPanel.getPreferredSize();	//To change body of overridden methods use File | Settings | File Templates.
	}

	{
// GUI initializer generated by IntelliJ IDEA GUI Designer
// >>> IMPORTANT!! <<<
// DO NOT EDIT OR ADD ANY CODE HERE!
		$$$setupUI$$$();
	}

	/**
	 * Method generated by IntelliJ IDEA GUI Designer
	 * >>> IMPORTANT!! <<<
	 * DO NOT edit this method OR call it in your code!
	 *
	 * @noinspection ALL
	 */
	private void $$$setupUI$$$() {
		rootPanel = new JPanel();
		rootPanel.setLayout(new FormLayout("fill:d:grow", "center:m:noGrow,center:m:grow,center:m:noGrow,center:max(d;4px):noGrow"));
		final JScrollPane scrollPane1 = new JScrollPane();
		CellConstraints cc = new CellConstraints();
		rootPanel.add(scrollPane1, cc.xy(1, 2, CellConstraints.FILL, CellConstraints.FILL));
		scrollPane1.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), null));
		commentTextArea = new JTextArea();
		commentTextArea.setText("");
		scrollPane1.setViewportView(commentTextArea);
		bottomButtonsPanel = new JPanel();
		bottomButtonsPanel.setLayout(new FormLayout("fill:67px:noGrow,left:4dlu:noGrow,fill:m:noGrow,fill:m:noGrow,fill:d:grow,fill:m:noGrow,fill:m:noGrow,fill:max(m;4px):noGrow", "center:d:noGrow"));
		rootPanel.add(bottomButtonsPanel, cc.xy(1, 3, CellConstraints.FILL, CellConstraints.CENTER));
		postButton = new JButton();
		postButton.setText("Post");
		bottomButtonsPanel.add(postButton, cc.xy(7, 1, CellConstraints.RIGHT, CellConstraints.DEFAULT));
		saveAsDraftButton = new JButton();
		saveAsDraftButton.setText("Save As Draft");
		bottomButtonsPanel.add(saveAsDraftButton, cc.xy(6, 1, CellConstraints.RIGHT, CellConstraints.DEFAULT));
		defectCheckBox = new JCheckBox();
		defectCheckBox.setText("Defect");
		bottomButtonsPanel.add(defectCheckBox, cc.xy(1, 1, CellConstraints.LEFT, CellConstraints.DEFAULT));
		cancelButton = new JButton();
		cancelButton.setText("Cancel");
		bottomButtonsPanel.add(cancelButton, cc.xy(8, 1, CellConstraints.RIGHT, CellConstraints.DEFAULT));
		rankComboBox = new JComboBox();
		bottomButtonsPanel.add(rankComboBox, cc.xy(3, 1, CellConstraints.LEFT, CellConstraints.DEFAULT));
		classificationComboBox = new JComboBox();
		bottomButtonsPanel.add(classificationComboBox, cc.xy(4, 1, CellConstraints.LEFT, CellConstraints.DEFAULT));
		final Spacer spacer1 = new Spacer();
		bottomButtonsPanel.add(spacer1, cc.xy(5, 1, CellConstraints.FILL, CellConstraints.DEFAULT));
		topButtonsPanel = new JPanel();
		topButtonsPanel.setLayout(new FormLayout("fill:m:grow,fill:94px:grow,fill:72px:noGrow,left:72px:noGrow,fill:m:noGrow,fill:max(m;4px):noGrow,fill:max(m;4px):noGrow,fill:max(m;4px):noGrow", "center:m:noGrow"));
		topButtonsPanel.setBackground(new Color(-1376257));
		rootPanel.add(topButtonsPanel, cc.xy(1, 1));
		editTopButton = new JButton();
		editTopButton.setText("Edit");
		topButtonsPanel.add(editTopButton, cc.xy(6, 1, CellConstraints.RIGHT, CellConstraints.DEFAULT));
		replyTopButton = new JButton();
		replyTopButton.setText("Reply");
		topButtonsPanel.add(replyTopButton, cc.xy(5, 1, CellConstraints.RIGHT, CellConstraints.CENTER));
		deleteTopButton = new JButton();
		deleteTopButton.setText("Delete");
		topButtonsPanel.add(deleteTopButton, cc.xy(7, 1, CellConstraints.RIGHT, CellConstraints.DEFAULT));
		postTopButton = new JButton();
		postTopButton.setText("Post");
		topButtonsPanel.add(postTopButton, cc.xy(8, 1, CellConstraints.RIGHT, CellConstraints.DEFAULT));
		draftTopLabel = new JLabel();
		draftTopLabel.setForeground(new Color(-39424));
		draftTopLabel.setText("Label");
		topButtonsPanel.add(draftTopLabel, new CellConstraints(4, 1, 1, 1, CellConstraints.FILL, CellConstraints.DEFAULT, new Insets(0, 10, 0, 0)));
		authorTopLabel = new JLabel();
		authorTopLabel.setText("Label");
		topButtonsPanel.add(authorTopLabel, cc.xy(1, 1, CellConstraints.FILL, CellConstraints.DEFAULT));
		final Spacer spacer2 = new Spacer();
		topButtonsPanel.add(spacer2, cc.xy(2, 1, CellConstraints.FILL, CellConstraints.DEFAULT));
		defectTopLabel = new JLabel();
		defectTopLabel.setForeground(new Color(-3407872));
		defectTopLabel.setText("Label");
		topButtonsPanel.add(defectTopLabel, cc.xy(3, 1));
		replyPanel = new JPanel();
		replyPanel.setLayout(new FormLayout("fill:d:grow", "center:138px:grow"));
		rootPanel.add(replyPanel, cc.xy(1, 4, CellConstraints.DEFAULT, CellConstraints.FILL));
		final JScrollPane scrollPane2 = new JScrollPane();
		replyPanel.add(scrollPane2, new CellConstraints(1, 1, 1, 1, CellConstraints.FILL, CellConstraints.FILL, new Insets(0, 20, 0, 0)));
		replyList = new JList();
		scrollPane2.setViewportView(replyList);
	}

	/**
	 * @noinspection ALL
	 */
	public JComponent $$$getRootComponent$$$() {
		return rootPanel;
	}

	/* EDIT - comment in edit mode
			   READ_ONLY - comment that was not created by viewer in read only mode
			   READ_ONLY_EDITABLE - comment in read only mode created by viewer and can be edited
			* */
	public enum CommentState {
		NEW, EDIT, READ_ONLY
	}

	public enum CommentType {
		GENAREAL_COMMENT, FILE_COMMENT, LINE_COMMENT, REPLY
	}

	public static List<CustomFieldDef> getMetricsVersion(Server server, int metricVersion) {
		if (METRICS_VERSIONS.get(new Integer(metricVersion)) != null) {
			return METRICS_VERSIONS.get(new Integer(metricVersion));
		} else {
			try {
				List<CustomFieldDef> customFields = CrucibleServerFacadeImpl.getInstance().getMetrics(server, metricVersion);
				METRICS_VERSIONS.put(new Integer(metricVersion), customFields);
				return customFields;
			} catch (RemoteApiException e) {
				PluginUtil.getLogger().error(e.getMessage());
			} catch (ServerPasswordNotProvidedException e) {
				PluginUtil.getLogger().error(e.getMessage());
			}

			return null;
		}
	}


	public CrucibleCommentPanel(ReviewData reviewData, GeneralComment comment, CommentState commentState) {
		this.commentState = commentState;
		init(reviewData, comment);


	}

	public CrucibleCommentPanel(ReviewData reviewData, GeneralComment comment) {
		if (comment.getPermId() != null && comment.getPermId().getId().length() > 0) {
			//no pernmID == new comment or reply
			this.commentState = CommentState.READ_ONLY;
		} else {
			this.commentState = CommentState.NEW;
		}
		init(reviewData, comment);

	}


	private void init(ReviewData reviewData, GeneralComment comment) {
		$$$setupUI$$$();
		commentType = determineCommentType(comment);
		listModel = new DefaultListModel();
		replyList.setModel(listModel);
		replyList.setCellRenderer(this);
		replyList.addListSelectionListener(this);

		setComment(comment);
		this.reviewData = reviewData;

		rootPanel.registerKeyboardAction(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				onCancel(e);
			}
		}, KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);

		initActionListeners();

		//replyList.setSelectionModel(ListSelectionModel.);
		draftTopLabel.setText("");
		defectTopLabel.setText("");
		if (comment.isDefectRaised()) {
			defectTopLabel.setText(DEFECT);
		}

		if (comment.isDraft()) {
			draftTopLabel.setText(DRAFT);
		}

		authorTopLabel.setText(comment.getDisplayUser());
		setMode(commentState);

	}

	private void addReply(GeneralComment item) {
		if (!item.isDraft()) {// && comment.getUser().equals(reviewData.getServer().getUserName())) {
			listModel.addElement(item);
		}
	}

	/*
	* Handles click on top reply button -> transits to some edit mode == no top buttons
	* Add new reply to comment
	* */
	private void newReply() {
		GeneralCommentBean commentBean = new GeneralCommentBean();
		commentBean.setReply(true);

		listModel.addElement(commentBean);
		replyPanel.setPreferredSize(replyList.getPreferredSize());
		replyPanel.setVisible(true);

	}

	private void setComment(GeneralComment comment) {
		this.comment = (GeneralCommentBean) comment;
		commentTextArea.setText(comment.getMessage());

		if (!comment.isReply() && comment.getReplies().size() > 0) {
			for (GeneralComment item : comment.getReplies()) {
				addReply(item);
			}
		} else {
			//do not show reply panel if no replies or REPLY
			replyPanel.setVisible(false);
		}
	}

	protected void initActionListeners() {
		postButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				onPost(false);
			}
		});

		saveAsDraftButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				onPost(true);
			}
		});

		cancelButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				onCancel(event);
			}
		});

		defectCheckBox.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				setDefectCombosVisible(defectCheckBox.isSelected());
			}
		});


		editTopButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				onTopEdit();
			}
		});

		replyTopButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				newReply();
			}
		});

		deleteTopButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				onTopDelete();
			}
		});

		postTopButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent event) {
				onTopPost();
			}
		});
	}

	private void fillInDefectCombos() {
		List<CustomFieldDef> fieldsDef = getMetricsVersion(reviewData.getServer(), reviewData.getMetricsVersion());

		for (CustomFieldDef item : fieldsDef) {
			List<CustomFieldValue> values;
			if (item.getName().equals(RANK)) {
				values = item.getValues();
				rankComboBox.removeAllItems();
				rankComboBox.setName(item.getName());
				for (CustomFieldValue value : values) {
					rankComboBox.addItem(new CustomFieldValueComboBoxItem(value));

				}
			}
			if (item.getName().equals(CLASSIFICATION)) {
				values = item.getValues();
				classificationComboBox.removeAllItems();
				classificationComboBox.setName(item.getLabel());
				for (CustomFieldValue value : values) {
					classificationComboBox.addItem(new CustomFieldValueComboBoxItem(value));
				}

			}

		}


	}


	protected void onPost(boolean saveAsDraft) {


		this.comment.setMessage(commentTextArea.getText());
		this.comment.setPermId(reviewData.getPermId());
		this.comment.setDraft(saveAsDraft);

		try {
			crucibleFacade.updateGeneralComment(reviewData.getServer(), reviewData.getPermId(), this.comment);
		} catch (RemoteApiException e) {
			//@todo show message in window
			PluginUtil.getLogger().error(e.getMessage());
		} catch (ServerPasswordNotProvidedException e) {
			//@todo show message in window
			PluginUtil.getLogger().error(e.getMessage());
		}

		setMode(CommentState.READ_ONLY);
	}

	private CommentType determineCommentType(GeneralComment comment) {
		if (comment.isReply()) {
			return CommentType.REPLY;
		}

		if (comment instanceof VersionedComment) {
			VersionedComment verComment = (VersionedComment) comment;

			if (verComment.isFromLineInfo() || verComment.isToLineInfo()) {
				return CommentType.LINE_COMMENT;
			} else {
				return CommentType.FILE_COMMENT;
			}
		}

		return CommentType.GENAREAL_COMMENT;
	}


	private void onTopDelete() {
		try {
			crucibleFacade.removeGeneralComment(reviewData.getServer(), this.comment.getPermId(), this.comment);
		} catch (RemoteApiException e) {
			PluginUtil.getLogger().error(e.getMessage());
		} catch (ServerPasswordNotProvidedException e) {
			PluginUtil.getLogger().error(e.getMessage());
		}

	}

	private void onTopPost() {
		if (!this.comment.isReply()) {
			onPost(false);
		} else {
			try {
				crucibleFacade.publishComment(reviewData.getServer(), reviewData.getPermId(), comment.getPermId());
			} catch (RemoteApiException e) {
				PluginUtil.getLogger().error(e.getMessage());
			} catch (ServerPasswordNotProvidedException e) {
				PluginUtil.getLogger().error(e.getMessage());
			}

			setMode(CommentState.READ_ONLY);
		}

	}

	/*
		* Disables all top buuttons and transits component to EDIT MODE = no top button only selected button on the bottom
		* */
	private void onTopEdit() {
		setMode(CommentState.EDIT);
	}

	private void onCancel(ActionEvent event) {
		if (event.getSource() instanceof CrucibleCommentPanel) {

			PluginUtil.getLogger().debug("");

		}
		if (this.commentState == CommentState.NEW) {
			listModel.removeElement(this);
		}
		setMode(CommentState.READ_ONLY);

	}

	private void setDefectCombosVisible(Boolean visible) {
		if (visible) {
			fillInDefectCombos();
			rankComboBox.setVisible(true);
			classificationComboBox.setVisible(true);
		} else {
			rankComboBox.setVisible(false);
			classificationComboBox.setVisible(false);
		}
	}

	private void setMode(CommentState commentState) {

		this.commentState = commentState;

		switch (commentState) {
			case EDIT:
				commentTextArea.setBackground(Color.WHITE);

				topButtonsPanel.setVisible(false);
				bottomButtonsPanel.setVisible(true);
				saveAsDraftButton.setVisible(false);
				//Reply do not have DEFECT check box
				if (comment.isReply()) {
					defectCheckBox.setVisible(false);
					setDefectCombosVisible(false);
				} else {
					defectCheckBox.setVisible(true);
					setDefectCombosVisible(defectCheckBox.isSelected());
				}
				break;
			case NEW:
				commentTextArea.setBackground(Color.WHITE);
				topButtonsPanel.setVisible(false);
				bottomButtonsPanel.setVisible(true);
				saveAsDraftButton.setVisible(true);
				defectCheckBox.setVisible(true);
				setDefectCombosVisible(defectCheckBox.isSelected());

				break;
			case READ_ONLY:
				if (comment.getUser().equals(reviewData.getServer().getUserName())) {
					topButtonsPanel.setBackground(new Color(234, 255, 255));
				} else {
					topButtonsPanel.setBackground(new Color(255, 255, 215));
				}

				commentTextArea.setBackground(new Color(234, 255, 255));
				//not editable, top panel visible, bottom panel not visible
				topButtonsPanel.setVisible(true);
				bottomButtonsPanel.setVisible(false);

				if (comment.getUser().equals(reviewData.getServer().getUserName())) {
					//top EDIT, REPLY visible, editable
					editTopButton.setVisible(true);
					deleteTopButton.setVisible(true);
				} else {
					//top EDIT, REPLY not visible
					editTopButton.setVisible(false);
					deleteTopButton.setVisible(false);
				}

				//for drafts top POST button is visible
				if (comment.isDraft() && comment.getUser().equals(reviewData.getServer().getUserName())) {
					postTopButton.setVisible(true);
				} else {
					postTopButton.setVisible(false);
				}
				//for REPLYies disable top REPLY button
				if (commentType == CommentType.REPLY) {
					replyTopButton.setVisible(false);
				} else {
					replyTopButton.setVisible(true);
				}


				break;


		}

	}

	private class CustomFieldValueComboBoxItem {
		private final CustomFieldValue value;

		public CustomFieldValueComboBoxItem(CustomFieldValue value) {
			this.value = value;
		}

		public String toString() {
			return value.getName();
		}

		public CustomFieldValue getUserData() {
			return value;
		}
	}
}

